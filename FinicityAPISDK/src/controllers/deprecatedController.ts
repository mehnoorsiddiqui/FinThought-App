/**
 * Finicity APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { Error1Error } from '../errors/error1Error';
import {
  AddCustomerRequest,
  addCustomerRequestSchema,
} from '../models/addCustomerRequest';
import {
  AddCustomerResponse,
  addCustomerResponseSchema,
} from '../models/addCustomerResponse';
import { AppStatusesV1, appStatusesV1Schema } from '../models/appStatusesV1';
import {
  AuditableReport,
  auditableReportSchema,
} from '../models/auditableReport';
import {
  CustomerAccounts,
  customerAccountsSchema,
} from '../models/customerAccounts';
import {
  GenerateConnectEmailRequest,
  generateConnectEmailRequestSchema,
} from '../models/generateConnectEmailRequest';
import {
  GenerateConnectEmailResponseMultiBorrowers,
  generateConnectEmailResponseMultiBorrowersSchema,
} from '../models/generateConnectEmailResponseMultiBorrowers';
import {
  GenerateConnectURLRequest,
  generateConnectURLRequestSchema,
} from '../models/generateConnectURLRequest';
import {
  GenerateConnectURLRequestDataAndPayments,
  generateConnectURLRequestDataAndPaymentsSchema,
} from '../models/generateConnectURLRequestDataAndPayments';
import {
  GenerateConnectURLRequestFix,
  generateConnectURLRequestFixSchema,
} from '../models/generateConnectURLRequestFix';
import {
  GenerateConnectURLRequestLending,
  generateConnectURLRequestLendingSchema,
} from '../models/generateConnectURLRequestLending';
import {
  GenerateConnectURLRequestLite,
  generateConnectURLRequestLiteSchema,
} from '../models/generateConnectURLRequestLite';
import {
  GenerateConnectURLResponse,
  generateConnectURLResponseSchema,
} from '../models/generateConnectURLResponse';
import {
  InvoiceBillingResponse,
  invoiceBillingResponseSchema,
} from '../models/invoiceBillingResponse';
import {
  PayStatementReportRecord,
  payStatementReportRecordSchema,
} from '../models/payStatementReportRecord';
import {
  PrequalificationReportNonCRA,
  prequalificationReportNonCRASchema,
} from '../models/prequalificationReportNonCRA';
import {
  StatementReportRecord,
  statementReportRecordSchema,
} from '../models/statementReportRecord';
import {
  TransactionsReportRecord,
  transactionsReportRecordSchema,
} from '../models/transactionsReportRecord';
import {
  VOAReportRecord,
  vOAReportRecordSchema,
} from '../models/vOAReportRecord';
import {
  VOAWithIncomeReportRecord,
  vOAWithIncomeReportRecordSchema,
} from '../models/vOAWithIncomeReportRecord';
import {
  VOIEPaystubWithTxverifyReportRecord,
  vOIEPaystubWithTxverifyReportRecordSchema,
} from '../models/vOIEPaystubWithTxverifyReportRecord';
import {
  VOIReportRecord,
  vOIReportRecordSchema,
} from '../models/vOIReportRecord';
import { bigint, optional, string } from '../schema';
import { BaseController } from './baseController';

export class DeprecatedController extends BaseController {
  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AuditableReport>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(auditableReportSchema, requestOptions);
  }

  /**
   * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
   * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
   * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
   * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
   *
   * Once you have generated the link it will only last until the authentication token under which it was
   * generated expires.  After that you will need to regenerate the Connect link under a new
   * authentication token. We recommend generating a new authentication token when you generate a Connect
   * link, to guarantee a full two hour life-span.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call.  Many times the type also
   * corresponds to the report that will be run upon completing the Connect flow.
   *
   * It is best to use the documentation for the specific use case you are interested in as the
   * documentation here is a list of all the possible parameters you can send for this endpoint depending
   * on the use case. See the following more specific documentation for your use case.......
   * Generate Finicity Connect URL (Data and Payments)
   * Generate Finicity Connect URL (Lending)
   * Generate Finicity Connect URL (Lite)
   * Generate Finicity Connect URL (Fix)
   *
   * @param accept application/json, application/xml
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async generateConnectURLAllTypes(
    accept: string,
    body: GenerateConnectURLRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectURLResponse>> {
    const req = this.createRequest('POST', '/connect/v1/generate');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectURLRequestSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(generateConnectURLResponseSchema, requestOptions);
  }

  /**
   * This service has been replaced by version 2 call now "Migrate Institution Login Accounts"
   *
   * This service is to migrate accounts from legacy FI to new OAuth FI.
   *
   * A successful API response will return a list of accounts for the given institution login id with an
   * http status code as 200.
   *
   * @param customerId         Finicity’s ID of the customer for the institutionLoginId of accounts
   * @param institutionLoginId Finicity's institutionLoginId for the set of accounts to be migrated
   * @param newInstitutionId   New OAuth FI ID where accounts  will be migrated
   * @return Response from the API call
   */
  async migrateInstitutionLoginAccountsV1(
    customerId: bigint,
    institutionLoginId: bigint,
    newInstitutionId: bigint,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CustomerAccounts>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      institutionLoginId: [institutionLoginId, bigint()],
      newInstitutionId: [newInstitutionId, bigint()],
    });
    req.appendTemplatePath`/aggregation/v1/customers/${mapped.customerId}/institutionLogins/${mapped.institutionLoginId}/institutions/${mapped.newInstitutionId}`;
    return req.callAsJson(customerAccountsSchema, requestOptions);
  }

  /**
   * Enroll a testing customer. A testing customer may only register accounts with FinBank institutions.
   *
   * @param contentType  application/json, application/xml
   * @param accept       application/json, application/xml
   * @param body         The Fields For The New Testing Customer
   * @return Response from the API call
   */
  async addTestingCustomerV1(
    contentType: string,
    accept: string,
    body: AddCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AddCustomerResponse>> {
    const req = this.createRequest('POST', '/aggregation/v1/customers/testing');
    const mapped = req.prepareArgs({
      contentType: [contentType, string()],
      accept: [accept, string()],
      body: [body, addCustomerRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(addCustomerResponseSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report (UUID with max length 32 characters)
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AuditableReport>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(auditableReportSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOAReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOAReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOAReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOIETxverifyReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOIEPaystubWithTxverifyReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(
      vOIEPaystubWithTxverifyReportRecordSchema,
      requestOptions
    );
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOIReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOIReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOIReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report (UUID with max length 32 characters)
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOIReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOIReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOIReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOAWithIncomeReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOAWithIncomeReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOAWithIncomeReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOAWithIncomeReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOAWithIncomeReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOAWithIncomeReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getPrequalificationVOAReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PrequalificationReportNonCRA>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(prequalificationReportNonCRASchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getPrequalificationReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PrequalificationReportNonCRA>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(prequalificationReportNonCRASchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getPayStatementByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PayStatementReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(payStatementReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOAReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOAReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(vOAReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getVOIETxverifyReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VOIEPaystubWithTxverifyReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(
      vOIEPaystubWithTxverifyReportRecordSchema,
      requestOptions
    );
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getPayStatementExtractionByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PayStatementReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(payStatementReportRecordSchema, requestOptions);
  }

  /**
   * This version 1 service has been replaced with version 2
   *
   * Enroll an active customer, which is the actual owner of one or more real-world accounts. This is a
   * billable customer.
   *
   * This service is not available from the Test Drive. Calls to this service before enrolling in a paid
   * plan will return HTTP 429 (Too Many Requests).
   *
   * @param accept       application/json, application/xml
   * @param contentType  application/json, application/xml
   * @param body         The Fields For The New Customer
   * @return Response from the API call
   */
  async addCustomerV1(
    accept: string,
    contentType: string,
    body: AddCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AddCustomerResponse>> {
    const req = this.createRequest('POST', '/aggregation/v1/customers/active');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      contentType: [contentType, string()],
      body: [body, addCustomerRequestSchema],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    return req.callAsJson(addCustomerResponseSchema, requestOptions);
  }

  /**
   * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
   * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
   * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
   * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
   *
   * Once you have generated the link it will only last until the authentication token under which it was
   * generated expires.  After that you will need to regenerate the Connect link under a new
   * authentication token. We recommend generating a new authentication token when you generate a Connect
   * link, to guarantee a full two hour life-span.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call.
   *
   * See the specific documentation for the types to see more details on the flow. This documentation
   * gives the applicable implementation details for the following types......
   *
   * - ach
   * - aggregation
   *
   * @param accept application/json, application/xml
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async generateConnectURLDataAndPaymentsConnect(
    accept: string,
    body: GenerateConnectURLRequestDataAndPayments,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectURLResponse>> {
    const req = this.createRequest('POST', '/connect/v1/generate');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectURLRequestDataAndPaymentsSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(generateConnectURLResponseSchema, requestOptions);
  }

  /**
   * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
   * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
   * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
   * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
   *
   * Once you have generated the link it will only last until the authentication token under which it was
   * generated expires.  After that you will need to regenerate the Connect link under a new
   * authentication token. We recommend generating a new authentication token when you generate a Connect
   * link, to guarantee a full two hour life-span.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call. For lending, each type signifies a
   * report that will be generated as part of the connect flow unless otherwise specified.
   *
   * See the specific documentation for the types to see more details on the flow. This documentation
   * gives the applicable implementation details for the following types......
   *
   * - voa
   * - voahistory
   * - voi
   * - voieTxVerify
   * - voieStatement
   * - payStatement
   * - assetSummary
   * - preQualVoa
   *
   * @param accept application/json, application/xml
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async generateConnectURLLending(
    accept: string,
    body: GenerateConnectURLRequestLending,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectURLResponse>> {
    const req = this.createRequest('POST', '/connect/v1/generate');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectURLRequestLendingSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(generateConnectURLResponseSchema, requestOptions);
  }

  /**
   * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
   * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
   * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
   * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
   *
   * Once you have generated the link it will only last until the authentication token under which it was
   * generated expires.  After that you will need to regenerate the Connect link under a new
   * authentication token. We recommend generating a new authentication token when you generate a Connect
   * link, to guarantee a full two hour life-span.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call.
   *
   * See the specific documentation for the types to see more details on the flow. This documentation
   * gives the applicable implementation details for the following types......
   *
   * - lite
   *
   * @param accept application/json, application/xml
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async generateConnectURLLite(
    accept: string,
    body: GenerateConnectURLRequestLite,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectURLResponse>> {
    const req = this.createRequest('POST', '/connect/v1/generate');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectURLRequestLiteSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(generateConnectURLResponseSchema, requestOptions);
  }

  /**
   * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
   * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
   * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
   * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
   *
   * Once you have generated the link it will only last until the authentication token under which it was
   * generated expires.  After that you will need to regenerate the Connect link under a new
   * authentication token. We recommend generating a new authentication token when you generate a Connect
   * link, to guarantee a full two hour life-span.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call.
   *
   * See the specific documentation for the types to see more details on the flow. This documentation
   * gives the applicable implementation details for the following types......
   *
   * - fix
   *
   * @param accept application/json, application/xml
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async generateConnectURLFix(
    accept: string,
    body: GenerateConnectURLRequestFix,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectURLResponse>> {
    const req = this.createRequest('POST', '/connect/v1/generate');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectURLRequestFixSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(generateConnectURLResponseSchema, requestOptions);
  }

  /**
   * A connect email sends an email to the customer which will contain a link to the connect flow. You
   * will need to specify what type of Finicity Connect you need depending on what will happen once the
   * customer accounts and transaction data are gathered.
   *
   * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
   * The Connect type is controlled by the “type” code in the call.  Many times the type also
   * corresponds to the report that will be run upon completing the Connect flow.
   *
   * For Send Connect Email service it does not support the types aggregation, lite and fix.
   *
   * See the endpoint Generate Finicity Connect URL (Lending) for additional details on a non email
   * implementation.
   *
   * @param accept application/json
   * @param body   Expected body to be sent with the request
   * @return Response from the API call
   */
  async sendConnectEmail(
    accept: string,
    body: GenerateConnectEmailRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GenerateConnectEmailResponseMultiBorrowers>> {
    const req = this.createRequest('POST', '/connect/v1/send/email');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      body: [body, generateConnectEmailRequestSchema],
    });
    req.header('Accept', mapped.accept);
    req.json(mapped.body);
    return req.callAsJson(
      generateConnectEmailResponseMultiBorrowersSchema,
      requestOptions
    );
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report (UUID with max length 32 characters)
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getTransactionsReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TransactionsReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(transactionsReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       JSON or  XML
   * @param contentType  JSON or  XML
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getTransactionsReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TransactionsReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(transactionsReportRecordSchema, requestOptions);
  }

  /**
   * Get the status of your application registration to access FI's with OAuth connections.
   *
   * @return Response from the API call
   */
  async getAppRegistrationStatusV1(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AppStatusesV1>> {
    const req = this.createRequest(
      'GET',
      '/aggregation/v1/partners/applications'
    );
    return req.callAsJson(appStatusesV1Schema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param customerId   Finicity’s ID of the customer
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getStatementReportByCustomer(
    customerId: bigint,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<StatementReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      customerId: [customerId, bigint()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/customers/${mapped.customerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(statementReportRecordSchema, requestOptions);
  }

  /**
   * Get a report that has been generated by calling one of the Generate Report services.
   *
   * The report's status field will contain inProgress, failure, or success. If the status shows
   * inProgress, the client app should wait 20 seconds and then call again to see if the report is
   * finished.
   *
   * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
   *
   * @param consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
   * @param reportId     Finicity’s ID of the report
   * @param accept       Replace 'json' with 'xml' if preferred
   * @param contentType  Replace 'json' with 'xml' if preferred
   * @param onBehalfOf   The name of the entity you are retrieving the report on behalf of.
   * @param purpose      2-digit code from Permissible Purpose Codes, specifying the reason for retrieving
   *                               this report.
   * @return Response from the API call
   */
  async getStatementReportByConsumer(
    consumerId: string,
    reportId: string,
    accept: string,
    contentType: string,
    onBehalfOf?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<StatementReportRecord>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      consumerId: [consumerId, string()],
      reportId: [reportId, string()],
      accept: [accept, string()],
      contentType: [contentType, string()],
      onBehalfOf: [onBehalfOf, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.query('onBehalfOf', mapped.onBehalfOf);
    req.query('purpose', mapped.purpose);
    req.appendTemplatePath`/decisioning/v1/consumers/${mapped.consumerId}/reports/${mapped.reportId}`;
    req.throwOn(400, Error1Error, 'Bad Request');
    return req.callAsJson(statementReportRecordSchema, requestOptions);
  }

  /**
   * Partners would like the capability to see the reports generated for a specific date range as well as
   * the custom fields associated with the report. This will allow partners to determine which branches
   * have generated specific reports to better bill those branches
   *
   * @param accept             Replace 'json' with 'xml' if preferred
   * @param partnerId          Partner ID From Developer Portal
   * @param startDate          The earliest date to be analyzed in this report. This is required.  Note: The
   *                                     range between startDate and endDate must be 31 days or less.
   * @param endDate            The latest date to be analyzed in this report. This is required.
   * @param viewTestingReports Designate as true to only display testing reports in the response. By default,
   *                                     this is false.
   * @param size               The size of the results returned per page. By default, this is 100 results
   *                                     per page and can be no more than 1000 results per page. This is optional.
   * @param page               The page to be viewed. Zero based index. This is optional. Default 0.
   * @return Response from the API call
   */
  async invoiceBillingEndpoint(
    accept: string,
    partnerId: string,
    startDate: string,
    endDate: string,
    viewTestingReports: string,
    size?: string,
    page?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<InvoiceBillingResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      partnerId: [partnerId, string()],
      startDate: [startDate, string()],
      endDate: [endDate, string()],
      viewTestingReports: [viewTestingReports, string()],
      size: [size, optional(string())],
      page: [page, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.query('startDate', mapped.startDate);
    req.query('endDate', mapped.endDate);
    req.query('viewTestingReports', mapped.viewTestingReports);
    req.query('size', mapped.size);
    req.query('page', mapped.page);
    req.appendTemplatePath`/decisioning/v1/partners/${mapped.partnerId}/billing/reseller`;
    return req.callAsJson(invoiceBillingResponseSchema, requestOptions);
  }
}
