/**
 * Finicity APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  AddCustomerRequest,
  addCustomerRequestSchema,
} from '../models/addCustomerRequest';
import {
  AddCustomerResponse,
  addCustomerResponseSchema,
} from '../models/addCustomerResponse';
import { Customer, customerSchema } from '../models/customer';
import {
  CustomerWithApplicationData,
  customerWithApplicationDataSchema,
} from '../models/customerWithApplicationData';
import {
  GetCustomersResponse,
  getCustomersResponseSchema,
} from '../models/getCustomersResponse';
import {
  ModifyCustomerRequest,
  modifyCustomerRequestSchema,
} from '../models/modifyCustomerRequest';
import { bigint, optional, string } from '../schema';
import { BaseController } from './baseController';

export class CustomerController extends BaseController {
  /**
   * Find all customers enrolled by the current partner, where the search text is found in the customer’s
   * username or any combination of firstName and lastName fields. If no search text is provided, return
   * all customers.
   *
   * Valid values for type are testing, active.
   *
   * If the value of moreAvailable in the response is true, you can retrieve the next page of results by
   * increasing the value of the start parameter in your next request:
   *
   * …&start=6&limit=5
   *
   * @param accept   application/json, application/xml
   * @param search   The text you wish to match. Leave this empty if you wish to return all customers. Must
   *                           be URL-encoded (see Handling Spaces in Queries)
   * @param username Username for exact match. (Will return 0 or 1 records.)
   * @param start    Starting index for this page of results. The default value is 1.
   * @param limit    Maximum number of entries for this page of results. The default value is 25.
   * @param type     One of the values testing or active to return only customers of that type, or leave
   *                           empty to return all customers.
   * @return Response from the API call
   */
  async getCustomers(
    accept: string,
    search?: string,
    username?: string,
    start?: bigint,
    limit?: bigint,
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GetCustomersResponse>> {
    const req = this.createRequest('GET', '/aggregation/v1/customers');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      search: [search, optional(string())],
      username: [username, optional(string())],
      start: [start, optional(bigint())],
      limit: [limit, optional(bigint())],
      type: [type, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.query('search', mapped.search);
    req.query('username', mapped.username);
    req.query('start', mapped.start);
    req.query('limit', mapped.limit);
    req.query('type', mapped.type);
    return req.callAsJson(getCustomersResponseSchema, requestOptions);
  }

  /**
   * Modify the details for an enrolled customer. You must specify either the first name, the last name,
   * or both in the request.
   *
   * If the service is successful, HTTP 204 (No Content) will be returned.
   *
   * @param contentType  application/json, application/xml
   * @param customerId   Finicity ‘s ID of the customer to modify
   * @param body         The information to be modified for the customer
   * @return Response from the API call
   */
  async modifyCustomer(
    contentType: string,
    customerId: bigint,
    body: ModifyCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      contentType: [contentType, string()],
      customerId: [customerId, bigint()],
      body: [body, modifyCustomerRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    req.appendTemplatePath`/aggregation/v1/customers/${mapped.customerId}`;
    return req.call(requestOptions);
  }

  /**
   * Get the details for the specified customer. The service will return HTTP 200 upon a successful call.
   * If the customer does not exist, the service will return HTTP 404.
   *
   * @param contentLength  Must be 0 (this request has no body)
   * @param accept         application/json, application/xml
   * @param customerId     Finicity’s ID of the customer
   * @return Response from the API call
   */
  async getCustomer(
    contentLength: string,
    accept: string,
    customerId: bigint,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      contentLength: [contentLength, string()],
      accept: [accept, string()],
      customerId: [customerId, bigint()],
    });
    req.header('Content-Length', mapped.contentLength);
    req.header('Accept', mapped.accept);
    req.appendTemplatePath`/aggregation/v1/customers/${mapped.customerId}`;
    return req.callAsJson(customerSchema, requestOptions);
  }

  /**
   * Completely remove a customer from the system. This will remove the customer and all associated
   * accounts and transactions.
   *
   * (Note that the request and response is the same for JSON or XML clients.)
   *
   * Use this service carefully! It will not pause for confirmation before performing the operation!
   *
   * Success: HTTP 204 (No Content)
   *
   * @param customerId Finicity’s ID of the customer to delete
   * @return Response from the API call
   */
  async deleteCustomer(
    customerId: bigint,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ customerId: [customerId, bigint()] });
    req.appendTemplatePath`/aggregation/v1/customers/${mapped.customerId}`;
    return req.call(requestOptions);
  }

  /**
   * This is a version 2 service that replaces version 1. The new version supports passing an
   * applicationId for assigning applicationId's to customers if a partner has more than one registered
   * app.
   *
   * Enroll an active customer, which is the actual owner of one or more real-world accounts. This is a
   * billable customer.
   *
   * This service is not available from the Test Drive. Calls to this service before enrolling in a paid
   * plan will return HTTP 429 (Too Many Requests).
   *
   * @param accept       application/json, application/xml
   * @param contentType  application/json, application/xml
   * @param body         The Fields For The New Customer
   * @return Response from the API call
   */
  async addCustomer(
    accept: string,
    contentType: string,
    body: AddCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AddCustomerResponse>> {
    const req = this.createRequest('POST', '/aggregation/v2/customers/active');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      contentType: [contentType, string()],
      body: [body, addCustomerRequestSchema],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    return req.callAsJson(addCustomerResponseSchema, requestOptions);
  }

  /**
   * This is a version 2 service that replaces version 1. The new version supports passing an
   * applicationId for assigning applicationId's to customers if a partner has more than one registered
   * app.
   *
   * Enroll a testing customer that is available for Test Drive accounts.
   *
   * For using testing customers when testing Finbank OAuth register a test application with your systems
   * engineer or account manager. You would then use that testing applicationId for the creating of any
   * testing customers. Testing customers can only be assigned to testing OAuth applications and Testing
   * customers can only add accounts to Finbank OAuth for testing OAuth implementation as well as other
   * Finbank testing institutions.
   *
   * @param accept       application/json, application/xml
   * @param contentType  application/json, application/xml
   * @param body         The Fields For The New Customer
   * @return Response from the API call
   */
  async addTestingCustomer(
    accept: string,
    contentType: string,
    body: AddCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AddCustomerResponse>> {
    const req = this.createRequest('POST', '/aggregation/v2/customers/testing');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      contentType: [contentType, string()],
      body: [body, addCustomerRequestSchema],
    });
    req.header('Accept', mapped.accept);
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    return req.callAsJson(addCustomerResponseSchema, requestOptions);
  }

  /**
   * Get the details for the specified customer with additional details that includes the OAuth
   * application info. The service will return HTTP 200 upon a successful call. If the customer does not
   * exist, the service will return HTTP 404.
   *
   * @param accept     application/json, application/xml
   * @param customerId Finicity’s ID of the customer
   * @return Response from the API call
   */
  async getCustomerWithApplicationData(
    accept: string,
    customerId: bigint,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CustomerWithApplicationData>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      customerId: [customerId, bigint()],
    });
    req.header('Accept', mapped.accept);
    req.appendTemplatePath`/aggregation/v1/customers/${mapped.customerId}/application`;
    return req.callAsJson(customerWithApplicationDataSchema, requestOptions);
  }
}
